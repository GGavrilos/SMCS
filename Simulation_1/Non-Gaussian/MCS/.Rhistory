################### IMPLEMENTATION OF TRADITIONAL MCS #######################
####################### NON-SEQUENTIAL SETTINGS #############################
set.seed(2025)
## install.package("scoringRules")
library(scoringRules)
library(MCS)
## Set parameters ##
T = 1000 # No. of time steps.
epsilon <- seq(-1,1,by = 1/3) # Deviation parameters of the forecasters (mean)
delta <- seq(-1, 1, by = 1/3)
parameters <- expand.grid(epsilon = epsilon, delta = delta) # Grid of deviation parameters "delta" and "epsilon".
parameters$Model <- as.character(paste0("model_", 1:length(epsilon)**2))
## Function computing the CRPS loss.
compute_crps <- function(eps, del, y_new, y_old){
crps_norm(y_new, mean = y_old + eps, sd = 1 + del)
}
crps_matrix <- matrix(0, nrow = 1, ncol = length(epsilon) * length(delta)) # Empty matrix to serve as loss matrix.
colnames(crps_matrix) <-  parameters$Model
y_old <- rnorm(1, mean = 0, sd = 1) # Observe first outcome.
y <- c(y_old) # Store outcomes in vector y.
size_MCS <- rep(length(epsilon)**2, T)
View(parameters)
################### IMPLEMENTATION OF TRADITIONAL MCS #######################
####################### NON-SEQUENTIAL SETTINGS #############################
set.seed(2025)
## install.package("scoringRules")
library(scoringRules)
library(MCS)
id <- as.integer(Sys.getenv("SLURM_ARRAY_TASK_ID"))
## Set parameters ##
T = 1000 # No. of time steps.
epsilon <- seq(-1,1,by = 1/3) # Deviation parameters of the forecasters (mean)
delta <- seq(-1, 1, by = 1/3)
parameters <- expand.grid(epsilon = epsilon, delta = delta) # Grid of deviation parameters "delta" and "epsilon".
parameters$Model <- as.character(paste0("model_", 1:length(epsilon)**2))
## Function computing the CRPS loss.
compute_crps <- function(eps, del, y_new, y_old){
crps_norm(y_new, mean = y_old + eps, sd = 1 + del)
}
crps_matrix <- matrix(0, nrow = 1, ncol = length(epsilon) * length(delta)) # Empty matrix to serve as loss matrix.
colnames(crps_matrix) <-  parameters$Model
y_old <- rnorm(1, mean = 0, sd = 1) # Observe first outcome.
y <- c(y_old) # Store outcomes in vector y.
mcs_hansen <- rep(length(epsilon)**2, T)
coverage <- rep(1, T)
## Start with a burn in phase
for (t in 2:20){
y_new <- rnorm(1, mean = y_old, sd = 1) # Observe new outcome
y[t] <- y_new # Append new outcome at the end of the outcome vector
crps_matrix <- rbind(crps_matrix, compute_crps(eps = parameters$epsilon,
del = parameters$delta,
y_new = y_new,
y_old = y_old))
y_old <- y_new # The new outcome now becomes old
}
for (t in 21:T){
y_new <- rnorm(1, mean = y_old, sd = 1) # Observe new outcome
y[t] <- y_new # Append new outcome at the end of the outcome vector
crps_matrix <- rbind(crps_matrix, compute_crps(eps = parameters$epsilon,
del = parameters$delta,
y_new = y_new,
y_old = y_old))
y_old <- y_new # The new outcome now becomes old
mcs_output <- MCSprocedure(Loss = crps_matrix, alpha = 0.1, B = 1000, statistic = "Tmax") # Run MCS algorithm
surviving_models <- rownames(mcs_output@show)  # Extract surviving models
# Ensure the parameters data frame keeps only surviving models
parameters <- subset(parameters, Model %in% surviving_models)
# Correctly subset crps_matrix without dimension mismatch
crps_matrix <- crps_matrix[, colnames(crps_matrix) %in% surviving_models,
drop = FALSE]
# Ensure column names are correctly set before subsetting
colnames(crps_matrix) <- parameters$Model
mcs_hansen[t] <- length(surviving_models)
if ("model_25" %in% surviving_models){
coverage[t] <- 1
}
else{
coverage[t] <- 0
}
if (length(surviving_models) == 1){ # Stop if only one model is remaining
break
}
}
mcs_hansen[t:T] <- rep(1, T-t+1)
coverage[t+1:T] <- rep(coverage[t], T-t)
export <- list(
Frequency = coverage,
Size_MCS = mcs_hansen
)
save(export, file = paste0("MCS=", id, ".rda"))
coverage
warnings()
warning()
